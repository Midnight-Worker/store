# store.py
import threading
import re
import serial
import webview

PORT = "/dev/ttyUSB1"   # anpassen
BAUDRATE = 115200

UID_USER  = "37:4A:B6:3B".upper()
UID_ADMIN = "B3:5C:BD:AB".upper()

BASE = "http://127.0.0.1:3000"
URL_USER  = f"{BASE}/"
URL_ADMIN = f"{BASE}/admin"

window = None
stop_flag = False

# --- Hilfen ---
def on_closing():
    return False

UID_RE = re.compile(r'^[0-9A-Fa-f]{2}(:[0-9A-Fa-f]{2}){3,}$')  # z.B. AA:BB:CC:DD oder länger
EAN_RE = re.compile(r'^\d{6,20}$')  # einfache Barcode-Heuristik (EAN-8/13, QR-Zahlen, SKU-Zahlen etc.)

def extract_uid(line: str):
    line = line.strip()
    if line.startswith("UID:"):
        uid_part = line.split("|")[0].replace("UID:", "").strip()
        return uid_part.upper()
    if UID_RE.match(line):
        return line.upper()
    return None

def extract_barcode(line: str):
    s = line.strip()
    # Optional: viele Scanner schicken Prefix/Suffix. Hier ein paar Beispiele:
    s = s.removeprefix("BC:").removeprefix("BARCODE:").strip()
    # Erlaube reine Ziffern (häufigster Fall). Willst du Alphanumerik, passe Regex an.
    if EAN_RE.match(s):
        return s
    return None

def go_role(role: str, next_url: str):
    # Cookie serverseitig setzen + redirect auf next
    role = role.lower()
    url = f"{BASE}/auth/set-role?role={role}&next={next_url}"
    window.load_url(url)

def handle_uid(uid: str):
    u = uid.upper()
    print("RFID:", u)
    if u == UID_ADMIN:
        print("→ ADMIN")
        go_role("admin", URL_ADMIN)
    elif u == UID_USER:
        print("→ USER")
        go_role("user", URL_USER)
    else:
        print("→ unbekannte UID (keine Navigation)")

def handle_barcode(code: str):
    print("BARCODE:", code)
    # Beliebige Normalisierung möglich (z.B. führende 0 trimmen o.ä.)
    window.load_url(f"{BASE}/item/{code}")

def serial_worker():
    global stop_flag
    try:
        with serial.Serial(PORT, BAUDRATE, timeout=1) as ser:
            print(f"[Serial] Listening on {PORT} @ {BAUDRATE} ...")
            while not stop_flag:
                raw = ser.readline().decode(errors="ignore").strip()
                if not raw:
                    continue

                # 1) UID?
                uid = extract_uid(raw)
                if uid:
                    handle_uid(uid)
                    continue

                # 2) Barcode?
                barcode = extract_barcode(raw)
                if barcode:
                    handle_barcode(barcode)
                    continue

                # Sonst: ignorieren/loggen
                # print("IGN:", raw)

    except serial.SerialException as e:
        print("[Serial] Fehler:", e)


def force_fullscreen():
    # 1) PyWebView-API
    try:
        window.toggle_fullscreen()  # setzt/entfernt Fullscreen
        # Falls du sicher "an" willst und du pywebview >= 4.3 hast:
        # window.set_fullscreen(True)
    except Exception:
        pass

    # 2) Fallback: Qt nativ (nur bei gui='qt')
    try:
        if hasattr(window, 'gui') and window.gui:
            window.gui.showFullScreen()
    except Exception:
        pass



def start_app():
    global window, stop_flag
    window = webview.create_window(
        "Kiosk",
        URL_USER,  # default
        fullscreen=True,
        frameless=True,
        easy_drag=False,
        confirm_close=True
    )
    window.events.closing += on_closing

    # WICHTIG: erst wenn das Fenster "gezeigt" wurde, Fullscreen erzwingen
    window.events.shown += force_fullscreen

    t = threading.Thread(target=serial_worker, daemon=True)
    t.start()
    try:
        webview.start(gui='qt')
    finally:
        stop_flag = True

if __name__ == '__main__':
    start_app()

